Context:
You have access to the existing frontend and backend projects.
Follow existing architecture and conventions strictly.

=====================================
BACKEND (IMPLEMENT FIRST)
=====================================

Backend Stack (do not deviate):
- ASP.NET Core
- Entity Framework Core
- CQRS pattern
- FluentValidation
- Riok.Mapperly for mapping
- Repository pattern
- Desyco.Mediator a fork library of MediatR already install ( only if already used in the project)

Backend Reference:
- EF Core Entity: [EntityName]

=====================================
FRONTEND (IMPLEMENT AFTER BACKEND)
=====================================

Frontend Stack (do not deviate):
- Vue 3
- Composition API only (no Options API)
- PrimeVue
- Tailwind CSS
- Axios
- Pinia stores

Frontend Reference:
- Component: [FrontendReferenceComponent].vue

CRUD UI Mode:
- Mode: [Modal-Based | Route-Based]

=====================================
TASK
=====================================

Goal:
Implement a full maintenance feature end-to-end (Backend first, then UI)
based on existing patterns and references.

=====================================
BACKEND RULES
=====================================

- Use the EF Core entity as the single source of truth.
- Do NOT modify the entity unless explicitly requested.
- Follow CQRS separation strictly (Commands vs Queries).
- Create ONE common DTO based on the entity.
- Reuse the DTO across:
  - Commands
  - Queries
  - Responses (when applicable)
- Do NOT duplicate DTOs unless explicitly required.

CQRS Structure:

Commands:
- Create[EntityName]Command
- Update[EntityName]Command
- Delete[EntityName]Command (if applicable)

Queries:
- Get[EntityName]ByIdQuery
- Get[EntityName]ListQuery

Validation:
- Use FluentValidation only.
- Validation must live exclusively in validators.
- No validation logic inside handlers.

Mapping:
- Use Riok.Mapperly only.
- Explicit mappings:
  - Entity ↔ DTO

Persistence:
- ALWAYS use the Repository pattern.
- Handlers must NOT access DbContext directly.
- If a repository already exists:
  - Follow its interface, naming, and structure.
- If no repository exists:
  - Create one following the exact same pattern
    used by existing repositories in the project.
- Repository responsibilities:
  - Data access only
  - No business logic
  - Async methods only

Seeder
- Add the new feature to FeatureSeeder and reorder the sequence

=====================================
FRONTEND RULES
=====================================

- Implement frontend ONLY after backend contracts are defined.
- Frontend models must match backend DTOs exactly.
- Use the reference component as the single source of truth.
- Follow the selected CRUD UI Mode strictly.
- Reuse layout, UX, and code patterns when applicable.
- Do NOT introduce new libraries or architectural changes.

Reusable UI patterns (when applicable):
- PrimeVue DataTable (pagination, sorting, filtering)
- Create/Edit via Dialog (Modal-Based)
- Create/Edit via Router views (Route-Based)
- PrimeVue form components
- Loading, error, and empty states
- Tailwind utility classes
- Pinia store (state, actions, loading, error)
- Axios service pattern

=====================================
INTEGRATION RULES
=====================================

- Backend DTOs define the API contract.
- Frontend must adapt to backend, never the opposite.
- Naming consistency between:
  - Entity
  - DTO
  - Commands / Queries
  - API endpoints
  - Frontend models
- Respect pagination, filtering, and sorting contracts.
- Do NOT assume fields, enums, or behaviors not explicitly defined.

=====================================
IMPLEMENTATION ORDER
=====================================

1. Analyze EF Core entity.
2. Define the common backend DTO.
3. Create or adapt the repository.
4. Implement Commands + Handlers.
5. Implement Queries + Handlers.
6. Add FluentValidation validators.
7. Add Mapperly mapper.
8. Verify backend contracts.
9. Implement frontend store, services, and components.

=====================================
OUTPUT
=====================================

Backend:
- Repository interface + implementation
- Common DTO
- Commands + Handlers
- Queries + Handlers
- FluentValidation validators
- Mapperly mapper

Frontend:
- Vue 3 component(s)
- Pinia store (if required)
- Axios service (if required)

Summary:
- CRUD UI Mode selected
- Backend elements created
- Frontend elements created
- Reused patterns
- Intentional omissions and reasons

/**************************************************/
VERSION ESPAÑOL
/**************************************************/

Contexto:
Tienes acceso a los proyectos de frontend y backend existentes.
Sigue estrictamente la arquitectura y convenciones existentes.

=====================================
BACKEND (IMPLEMENTAR PRIMERO)
=====================================

Stack Backend (no desviarse):
- ASP.NET Core
- Entity Framework Core
- Patrón CQRS
- FluentValidation
- Riok.Mapperly para mapeo
- Patrón Repository
- Desyco.Mediator, una librería fork de MediatR ya instalada (solo si ya se usa en el proyecto)

Referencia Backend:
- Entidad EF Core: [NombreDeLaEntidad]

=====================================
FRONTEND (IMPLEMENTAR DESPUÉS DEL BACKEND)
=====================================

Stack Frontend (no desviarse):
- Vue 3
- Solo Composition API (nada de Options API)
- PrimeVue
- Tailwind CSS
- Axios
- Stores de Pinia

Referencia Frontend:
- Componente: [ComponenteDeReferenciaFrontend].vue

Modo de UI CRUD:
- Modo: [Basado en Modal | Basado en Rutas]

=====================================
TAREA
=====================================

Objetivo:
Implementar una funcionalidad de mantenimiento completa end-to-end (Backend primero, luego UI)
basada en los patrones y referencias existentes.

=====================================
REGLAS BACKEND
=====================================

- Usa la entidad de EF Core como la única fuente de la verdad.
- NO modifiques la entidad a menos que se solicite explícitamente.
- Sigue estrictamente la separación CQRS (Comandos vs Consultas).
- Crea UN DTO común basado en la entidad.
- Reutiliza el DTO en:
  - Comandos (Commands)
  - Consultas (Queries)
  - Respuestas (cuando sea aplicable)
- NO dupliques DTOs a menos que sea explícitamente necesario.

Estructura CQRS:

Comandos (Commands):
- Create[NombreEntidad]Command
- Update[NombreEntidad]Command
- Delete[NombreEntidad]Command (si aplica)

Consultas (Queries):
- Get[NombreEntidad]ByIdQuery
- Get[NombreEntidad]ListQuery

Validación:
- Usa solo FluentValidation.
- La validación debe vivir exclusivamente en los validadores.
- No debe haber lógica de validación dentro de los handlers.

Mapeo:
- Usa solo Riok.Mapperly.
- Mapeos explícitos:
  - Entidad ↔ DTO

Persistencia:
- Usa SIEMPRE el patrón Repository.
- Los Handlers NO deben acceder al DbContext directamente.
- Si ya existe un repositorio:
  - Sigue su interfaz, nomenclatura y estructura.
- Si no existe un repositorio:
  - Crea uno siguiendo exactamente el mismo patrón
    usado por los repositorios existentes en el proyecto.
- Responsabilidades del Repositorio:
  - Solo acceso a datos
  - Nada de lógica de negocio
  - Solo métodos asíncronos (Async)

Seeder:
- Añade la nueva funcionalidad al FeatureSeeder y reordena la secuencia.

=====================================
REGLAS FRONTEND
=====================================

- Implementa el frontend SOLO después de que los contratos del backend estén definidos.
- Los modelos del frontend deben coincidir exactamente con los DTOs del backend.
- Usa el componente de referencia como la única fuente de verdad.
- Sigue estrictamente el Modo de UI CRUD seleccionado.
- Reutiliza el diseño (layout), UX y patrones de código cuando sea aplicable.
- NO introduzcas nuevas librerías ni cambios de arquitectura.
- Utiliza yup/vee-validate/yup para validaciones en la UI.

Patrones de UI reutilizables (cuando aplique):
- PrimeVue DataTable (paginación, ordenamiento, filtrado)
- Crear/Editar vía Diálogo (Modo Basado en Modal)
- Crear/Editar vía Vistas de Router (Modo Basado en Rutas)
- Componentes de formulario de PrimeVue
- Estados de carga (loading), error y vacío
- Clases de utilidad de Tailwind
- Store de Pinia (estado, acciones, loading, error)
- Patrón de servicio Axios

=====================================
REGLAS DE INTEGRACIÓN
=====================================

- Los DTOs del Backend definen el contrato de la API.
- El Frontend debe adaptarse al backend, nunca al revés.
- Consistencia de nomenclatura entre:
  - Entidad
  - DTO
  - Comandos / Consultas
  - Endpoints de API
  - Modelos de Frontend
- Respeta los contratos de paginación, filtrado y ordenamiento.
- NO asumas campos, enums o comportamientos que no estén explícitamente definidos.

=====================================
ORDEN DE IMPLEMENTACIÓN
=====================================

1. Analizar la entidad EF Core.
2. Definir el DTO común del backend.
3. Crear o adaptar el repositorio.
4. Implementar Comandos + Handlers.
5. Implementar Consultas + Handlers.
6. Añadir validadores FluentValidation.
7. Añadir mapper Riok.Mapperly.
8. Verificar contratos del backend.
9. Implementar store, servicios y componentes del frontend.

=====================================
SALIDA (ENTREGABLES)
=====================================

Backend:
- Interfaz e implementación del Repositorio
- DTO Común
- Comandos + Handlers
- Consultas + Handlers
- Validadores FluentValidation
- Mapper de Mapperly

Frontend:
- Componente(s) Vue 3
- Store de Pinia (si se requiere)
- Servicio Axios (si se requiere)

Resumen:
- Modo de UI CRUD seleccionado
- Elementos de backend creados
- Elementos de frontend creados
- Patrones reutilizados
- Omisiones intencionales y sus razones
