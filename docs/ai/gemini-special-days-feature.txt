Contexto:
Tienes acceso a los proyectos de frontend y backend existentes.
Sigue estrictamente la arquitectura y convenciones existentes.

=====================================
BACKEND (IMPLEMENTAR PRIMERO)
=====================================

Stack Backend (no desviarse):
- ASP.NET Core
- Entity Framework Core
- Patrón CQRS
- FluentValidation
- Riok.Mapperly para mapeo
- Patrón Repository
- Desyco.Mediator, una librería fork de MediatR ya instalada (solo si ya se usa en el proyecto)

Referencia Backend:
- Entidad EF Core: SpecialDayEntity

=====================================
FRONTEND (IMPLEMENTAR DESPUÉS DEL BACKEND)
=====================================

Stack Frontend (no desviarse):
- Vue 3
- Solo Composition API (nada de Options API)
- PrimeVue
- Tailwind CSS
- Axios
- Stores de Pinia

Referencias Frontend:
- Componente: EducationalLevelList.vue

Modo de UI CRUD:
- Modo: Basado en Modal

=====================================
TAREA
=====================================

Objetivo:
Implementar una funcionalidad de mantenimiento completa end-to-end (Backend primero, luego UI) basada en los patrones y referencias existentes.
Desarrollar un componente de gestión escolar para administrar "Días Especiales" (Special Days). El componente debe permitir un CRUD visual directamente sobre un calendario, utilizando los estilos de la plantilla.

=====================================
REGLAS BACKEND
=====================================

- Usa la entidad de EF Core como la única fuente de la verdad.
- NO modifiques la entidad a menos que se solicite explícitamente.
- Sigue estrictamente la separación CQRS (Comandos vs Consultas).
- Crea UN DTO común basado en la entidad.
- Reutiliza el DTO en:
  - Comandos (Commands)
  - Consultas (Queries)
  - Respuestas (cuando sea aplicable)
- NO dupliques DTOs a menos que sea explícitamente necesario.

Estructura CQRS:

Comandos (Commands):
- Create[NombreEntidad]Command
- Update[NombreEntidad]Command
- Delete[NombreEntidad]Command (si aplica)

Consultas (Queries):
- Get[NombreEntidad]ByIdQuery
- Get[NombreEntidad]ListQuery
- Get[NombreEntidad]ByPeriodQuery (Devuelve todos los dias especiales de un determinado Periodo de evaluacion)
- Get[NombreEntidad]ByAcademicYearQuery (Devuelve todos los dias especiales de un determinado ano academico)

Validación:
- Usa solo FluentValidation.
- La validación debe vivir exclusivamente en los validadores.
- No debe haber lógica de validación dentro de los handlers.

Mapeo:
- Usa solo Riok.Mapperly.
- Mapeos explícitos:
  - Entidad ↔ DTO

Persistencia:
- Usa SIEMPRE el patrón Repository.
- Los Handlers NO deben acceder al DbContext directamente.
- Si ya existe un repositorio:
  - Sigue su interfaz, nomenclatura y estructura.
- Si no existe un repositorio:
  - Crea uno siguiendo exactamente el mismo patrón
    usado por los repositorios existentes en el proyecto.
- Responsabilidades del Repositorio:
  - Solo acceso a datos
  - Nada de lógica de negocio
  - Solo métodos asíncronos (Async)

Seeder:
- Añade la nueva funcionalidad al FeatureSeeder y reordena la secuencia.

=====================================
REGLAS FRONTEND
=====================================

- Utiliza el componente `SpecialDaysView.vue` existente (Ya esta vinculado al menu lateral de la seccion SchoolSettings.vue)
- Implementa el frontend SOLO después de que los contratos del backend estén definidos.
- Los modelos del frontend deben coincidir exactamente con los DTOs del backend.
- Usa el componente de referencia para guiarte con la implementacion del CRUD (utiliza la misma configuracion del dialogo modal para crear y modificar dias especiales y la implementacion que se utiliza para eliminar registros)
- Sigue estrictamente el Modo de UI CRUD seleccionado.
- Reutiliza el diseño (layout), UX y patrones de código cuando sea aplicable.
- NO introduzcas nuevas librerías ni cambios de arquitectura.
- Siempre Utiliza `translations` para etiquetas, titulos, etc. siempre respetando el diseño y pastrones establecidos.

Patrones de UI reutilizables (cuando aplique):
- PrimeVue DataTable (paginación, ordenamiento, filtrado)
- Crear/Editar vía Diálogo (Modo Basado en Modal)
- Componentes de formulario de PrimeVue
- Estados de carga (loading), error y vacío
- Clases de utilidad de Tailwind
- Store de Pinia (estado, acciones, loading, error)
- Patrón de servicio Axios (configuracion existente)

Requerimientos Técnicos del Modelo
Basado en las siguientes definiciones de C#:
- Enum `SpecialDayType`:** - `SchoolClosure` (Value: "School Closure") -> Círculo Rojo (`bg-red-500`).
  - `TimingChange` (Value: "Timing Change") -> Círculo Naranja (`bg-orange-500`).
  - Otros -> Color Primario de la plantilla (`bg-primary`).

Configuración del Componente (DatePicker)
1. Vista Estática: - Usa `DatePicker` en modo inline.
   - Propiedades: `minDate`, `maxDate` y `disabledDays` (array de números de días de la semana a deshabilitar).
   - Lógica de visualización: Calcula dinámicamente el número de meses entre `minDate` y `maxDate` y asígnalo a `numberOfMonths`.
   - Orientación: Los meses deben apilarse en dos columnas (un mes para cada una) fijas y filas dinamicas que debe crecer a medida que se incrementa el numero de meses.
   - Ambas columnas deben tomar todo el ancho de elemento contenedor
   - Navegación: Oculta mediante CSS las flechas de navegación (`prev` y `next`). El usuario no debe poder salir del rango.

2. Personalización de Celdas (Slot `#date`):
   - Si el día está en `disabledDays`, la celda debe estar vacía.
   - Para días habilitados:
     - Mostrar el número del día dentro de un círculo con el color correspondiente según el `SpecialDayType`.
     - Si existe registro: Mostrar botones mini (`pi-pencil` y `pi-trash`) con severities `warn` y `danger`.
     - Si NO existe registro: Mostrar un botón mini (`pi-plus`) con `severity="success"`.

3. Interfaz de Usuario (Diálogo):
   - Implementa un `Dialog` que se abra para Crear o Editar.
   - El formulario debe incluir: `Name` (InputText), `Description` (Textarea), `Type` (Select con las opciones del Enum) y selectores de hora (`DatePicker` con `timeOnly`) para los campos de tiempo.
   - El campo `Date` debe ser de solo lectura.

Estilo y Layout
- Utiliza **Tailwind CSS** (tailwindcss-primeui ) para centrar el contenido de la celda.
- Asegúrate de que los botones mini no deformen la cuadrícula del calendario.
- Usa variables globales de la plantilla (como `--primary-color`) donde sea necesario.


=====================================
REGLAS DE INTEGRACIÓN
=====================================

- Los DTOs del Backend definen el contrato de la API.
- El Frontend debe adaptarse al backend, nunca al revés.
- Consistencia de nomenclatura entre:
  - Entidad
  - DTO
  - Comandos / Consultas
  - Endpoints de API
  - Modelos de Frontend
- Respeta los contratos de paginación, filtrado y ordenamiento (si aplica).
- NO asumas campos, enums o comportamientos que no estén explícitamente definidos.

=====================================
ORDEN DE IMPLEMENTACIÓN
=====================================

1. Analizar la entidad EF Core.
2. Definir el DTO común del backend.
3. Crear o adaptar el repositorio.
4. Implementar Comandos + Handlers.
5. Implementar Consultas + Handlers.
6. Añadir validadores FluentValidation.
7. Añadir mapper Riok.Mapperly.
8. Verificar contratos del backend.
9. Implementar store, servicios y componentes del frontend.

=====================================
SALIDA (ENTREGABLES)
=====================================

Backend:
- Interfaz e implementación del Repositorio
- DTO Común
- Comandos + Handlers
- Consultas + Handlers
- Validadores FluentValidation
- Mapper de Mapperly

Frontend:
- Componente(s) Vue 3
- Store de Pinia (si se requiere)
- Servicio Axios (si se requiere)

Resumen:
- Modo de UI CRUD seleccionado
- Elementos de backend creados
- Elementos de frontend creados
- Patrones reutilizados
- Omisiones intencionales y sus razones
